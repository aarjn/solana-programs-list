#!/usr/bin/env ts-node

import * as fs from "fs";
import * as path from "path";
import * as anchor from "@coral-xyz/anchor";
import { Program, AnchorProvider, BN } from "@coral-xyz/anchor";
import { PublicKey, Keypair, Connection, clusterApiUrl } from "@solana/web3.js";
import {
  MerkleTree,
  buildHolderEntries,
  proofToAnchorFormat,
  computeSelectionPoint,
} from "./merkle";

// IDL type - will be generated by anchor build
import type { AnchorMerkleTree } from "../target/types/anchor_merkle_tree";

const PROGRAM_ID = new PublicKey(
  "HSBQg9YYMu8DtD1pgTfwxTqTdGWTKHtxSjg5wT3bz1mi"
);

interface HolderData {
  [address: string]: string | number;
}

// Load IDL dynamically
function loadIdl(): any {
  const idlPath = path.join(__dirname, "../target/idl/anchor_merkle_tree.json");
  if (!fs.existsSync(idlPath)) {
    throw new Error(
      `IDL not found at ${idlPath}. Run 'anchor build' first.`
    );
  }
  return JSON.parse(fs.readFileSync(idlPath, "utf8"));
}

/**
 * Load holder data from JSON or CSV file
 */
function loadHolderData(filePath: string): HolderData {
  const ext = path.extname(filePath).toLowerCase();
  const content = fs.readFileSync(filePath, "utf8");

  if (ext === ".json") {
    return JSON.parse(content);
  } else if (ext === ".csv") {
    const holders: HolderData = {};
    const lines = content.trim().split("\n");

    // Skip header if present
    const startIndex = lines[0].includes("address") ? 1 : 0;

    for (let i = startIndex; i < lines.length; i++) {
      const [address, balance] = lines[i].split(",").map((s) => s.trim());
      if (address && balance) {
        holders[address] = balance;
      }
    }

    return holders;
  } else {
    throw new Error(`Unsupported file format: ${ext}. Use .json or .csv`);
  }
}

/**
 * Get the lottery PDA
 */
function getLotteryPda(authority: PublicKey): [PublicKey, number] {
  return PublicKey.findProgramAddressSync(
    [Buffer.from("lottery"), authority.toBuffer()],
    PROGRAM_ID
  );
}

/**
 * Build Merkle tree from holder data and output root
 */
async function buildTree(holderFile: string, outputFile?: string) {
  console.log(`Loading holder data from: ${holderFile}`);
  const holders = loadHolderData(holderFile);
  const holderCount = Object.keys(holders).length;
  console.log(`Loaded ${holderCount} holders`);

  console.log("\nBuilding Merkle tree...");
  const entries = buildHolderEntries(holders);
  const tree = new MerkleTree(entries);

  const root = tree.getRoot();
  const totalWeight = tree.getTotalWeight();

  console.log("\n=== Merkle Tree Info ===");
  console.log(`Holders: ${holderCount}`);
  console.log(`Total weight: ${totalWeight}`);
  console.log(`Merkle root: 0x${root.toString("hex")}`);
  console.log(`Root array: [${tree.getRootArray().join(", ")}]`);

  // Output to file if specified
  if (outputFile) {
    const output = {
      holderCount,
      totalWeight: totalWeight.toString(),
      merkleRoot: root.toString("hex"),
      merkleRootArray: tree.getRootArray(),
      entries: entries.map((e) => ({
        address: e.address.toBase58(),
        balance: e.balance.toString(),
        prevCumulative: e.prevCumulative.toString(),
        cumulative: e.cumulative.toString(),
      })),
    };
    fs.writeFileSync(outputFile, JSON.stringify(output, null, 2));
    console.log(`\nTree data saved to: ${outputFile}`);
  }

  return { tree, entries, root, totalWeight };
}

/**
 * Find winner from VRF result
 */
async function findWinner(
  holderFile: string,
  vrfResultHex: string,
  outputFile?: string
) {
  // Build tree
  const { tree, totalWeight } = await buildTree(holderFile);

  // Parse VRF result
  const vrfResult = Buffer.from(vrfResultHex.replace("0x", ""), "hex");
  if (vrfResult.length !== 32) {
    throw new Error("VRF result must be 32 bytes");
  }

  // Find winner
  const { entry, index } = tree.findWinner(vrfResult);
  const selectionPoint = computeSelectionPoint(vrfResult, totalWeight);

  console.log("\n=== Winner Selection ===");
  console.log(`VRF result: 0x${vrfResult.toString("hex")}`);
  console.log(`Selection point: ${selectionPoint}`);
  console.log(`Winner index: ${index}`);
  console.log(`Winner address: ${entry.address.toBase58()}`);
  console.log(`Winner balance: ${entry.balance}`);
  console.log(`Winner range: [${entry.prevCumulative}, ${entry.cumulative})`);

  // Generate proof
  const proof = tree.generateWinnerProof(vrfResult);

  console.log("\n=== Merkle Proof ===");
  console.log(`Proof length: ${proof.proof.length}`);
  proof.proof.forEach((p, i) => {
    console.log(`  [${i}]: 0x${p.toString("hex")}`);
  });

  // Verify proof
  const verified = tree.verifyProof(entry, proof.proof);
  console.log(`\nProof verification: ${verified ? "VALID" : "INVALID"}`);

  // Output to file if specified
  if (outputFile) {
    const output = {
      vrfResult: vrfResultHex,
      selectionPoint: selectionPoint.toString(),
      winnerIndex: index,
      winner: {
        address: entry.address.toBase58(),
        balance: entry.balance.toString(),
        prevCumulative: entry.prevCumulative.toString(),
        cumulative: entry.cumulative.toString(),
      },
      proof: proof.proof.map((p) => p.toString("hex")),
      proofArray: proof.proof.map((p) => Array.from(p)),
    };
    fs.writeFileSync(outputFile, JSON.stringify(output, null, 2));
    console.log(`\nWinner data saved to: ${outputFile}`);
  }

  return { entry, proof, selectionPoint };
}

/**
 * Load wallet from path
 */
function loadWallet(walletPath?: string): Keypair {
  const keyPath =
    walletPath ||
    path.join(process.env.HOME || "", ".config/solana/id.json");
  return Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(fs.readFileSync(keyPath, "utf8")))
  );
}

/**
 * Initialize lottery on-chain
 */
async function initializeLottery(
  holderFile: string,
  walletPath?: string,
  rpcUrl?: string
) {
  // Build tree first
  const { tree, totalWeight } = await buildTree(holderFile);
  const merkleRoot = tree.getRootArray();

  // Setup provider
  const connection = new Connection(rpcUrl || clusterApiUrl("devnet"));
  const wallet = loadWallet(walletPath);

  const provider = new AnchorProvider(
    connection,
    new anchor.Wallet(wallet),
    { commitment: "confirmed" }
  );

  const IDL = loadIdl();
  const program = new Program(IDL, provider) as Program<AnchorMerkleTree>;

  const [lotteryPda] = getLotteryPda(wallet.publicKey);

  console.log("\n=== Initializing Lottery ===");
  console.log(`Authority: ${wallet.publicKey.toBase58()}`);
  console.log(`Lottery PDA: ${lotteryPda.toBase58()}`);
  console.log(`Total weight: ${totalWeight}`);

  try {
    const tx = await program.methods
      .initializeLottery(merkleRoot as number[], new BN(totalWeight.toString()))
      .accountsStrict({
        lottery: lotteryPda,
        authority: wallet.publicKey,
        systemProgram: anchor.web3.SystemProgram.programId,
      })
      .signers([wallet])
      .rpc();

    console.log(`\nTransaction: ${tx}`);
    console.log("Lottery initialized successfully!");
  } catch (error: any) {
    if (error.message?.includes("already in use")) {
      console.log("\nLottery account already exists");
    } else {
      throw error;
    }
  }
}

/**
 * Set VRF result from Switchboard randomness account
 */
async function setVrfResult(
  randomnessAccountPubkey: string,
  walletPath?: string,
  rpcUrl?: string
) {
  // Setup provider
  const connection = new Connection(rpcUrl || clusterApiUrl("devnet"));
  const wallet = loadWallet(walletPath);

  const provider = new AnchorProvider(
    connection,
    new anchor.Wallet(wallet),
    { commitment: "confirmed" }
  );

  const IDL = loadIdl();
  const program = new Program(IDL, provider) as Program<AnchorMerkleTree>;

  const [lotteryPda] = getLotteryPda(wallet.publicKey);
  const randomnessAccount = new PublicKey(randomnessAccountPubkey);

  console.log("\n=== Setting VRF Result ===");
  console.log(`Lottery PDA: ${lotteryPda.toBase58()}`);
  console.log(`Randomness account: ${randomnessAccount.toBase58()}`);

  const tx = await program.methods
    .setVrfResult()
    .accountsStrict({
      lottery: lotteryPda,
      randomnessAccount,
      authority: wallet.publicKey,
    })
    .signers([wallet])
    .rpc();

  console.log(`\nTransaction: ${tx}`);
  console.log("VRF result set successfully!");

  // Fetch the lottery to show the VRF result
  const lottery = await program.account.lottery.fetch(lotteryPda);
  console.log(`\nVRF result: 0x${Buffer.from(lottery.vrfResult).toString("hex")}`);

  return Buffer.from(lottery.vrfResult);
}

/**
 * Claim winner with known lottery authority
 */
async function claimWinnerWithAuthority(
  holderFile: string,
  vrfResultHex: string,
  lotteryAuthority: string,
  winnerWalletPath: string,
  rpcUrl?: string
) {
  // Build tree and find winner
  const { tree } = await buildTree(holderFile);
  const vrfResult = Buffer.from(vrfResultHex.replace("0x", ""), "hex");
  const { entry } = tree.findWinner(vrfResult);
  const winnerProof = tree.generateWinnerProof(vrfResult);

  // Setup provider with winner's wallet
  const connection = new Connection(rpcUrl || clusterApiUrl("devnet"));
  const winnerWallet = Keypair.fromSecretKey(
    new Uint8Array(JSON.parse(fs.readFileSync(winnerWalletPath, "utf8")))
  );

  // Verify the wallet matches the winner
  if (!entry.address.equals(winnerWallet.publicKey)) {
    throw new Error(
      `Wallet ${winnerWallet.publicKey.toBase58()} is not the winner (${entry.address.toBase58()})`
    );
  }

  const provider = new AnchorProvider(
    connection,
    new anchor.Wallet(winnerWallet),
    { commitment: "confirmed" }
  );

  const IDL = loadIdl();
  const program = new Program(IDL, provider) as Program<AnchorMerkleTree>;

  const authorityPubkey = new PublicKey(lotteryAuthority);
  const [lotteryPda] = getLotteryPda(authorityPubkey);

  console.log("\n=== Claiming Winner ===");
  console.log(`Lottery authority: ${authorityPubkey.toBase58()}`);
  console.log(`Lottery PDA: ${lotteryPda.toBase58()}`);
  console.log(`Claimant (winner): ${winnerWallet.publicKey.toBase58()}`);

  const anchorProof = proofToAnchorFormat(winnerProof);

  const tx = await program.methods
    .claimWinner({
      address: anchorProof.address,
      balance: anchorProof.balance,
      prevCumulative: anchorProof.prevCumulative,
      cumulative: anchorProof.cumulative,
      proof: anchorProof.proof,
    })
    .accountsStrict({
      lottery: lotteryPda,
      claimant: winnerWallet.publicKey,
    })
    .signers([winnerWallet])
    .rpc();

  console.log(`\nTransaction: ${tx}`);
  console.log("Winner claimed successfully!");

  // Fetch the lottery to confirm
  const lottery = await program.account.lottery.fetch(lotteryPda);
  console.log(`\nLottery finalized: ${lottery.finalized}`);
  console.log(`Winner on-chain: ${lottery.winner?.toBase58()}`);
  console.log(`Winner weight: ${lottery.winnerWeight.toString()}`);
}

/**
 * Fetch lottery state
 */
async function getLotteryState(authority: string, rpcUrl?: string) {
  const connection = new Connection(rpcUrl || clusterApiUrl("devnet"));

  // Create a minimal provider for read-only operations
  const provider = new AnchorProvider(
    connection,
    {
      publicKey: PublicKey.default,
      signTransaction: async (tx: any) => tx,
      signAllTransactions: async (txs: any[]) => txs,
    } as any,
    { commitment: "confirmed" }
  );

  const IDL = loadIdl();
  const program = new Program(IDL, provider) as Program<AnchorMerkleTree>;

  const authorityPubkey = new PublicKey(authority);
  const [lotteryPda] = getLotteryPda(authorityPubkey);

  console.log("\n=== Lottery State ===");
  console.log(`Authority: ${authorityPubkey.toBase58()}`);
  console.log(`Lottery PDA: ${lotteryPda.toBase58()}`);

  try {
    const lottery = await program.account.lottery.fetch(lotteryPda);

    console.log(
      `\nMerkle root: 0x${Buffer.from(lottery.merkleRoot).toString("hex")}`
    );
    console.log(
      `VRF result: 0x${Buffer.from(lottery.vrfResult).toString("hex")}`
    );
    console.log(`Total weight: ${lottery.totalWeight.toString()}`);
    console.log(`Winner: ${lottery.winner?.toBase58() || "None"}`);
    console.log(`Winner weight: ${lottery.winnerWeight.toString()}`);
    console.log(`Finalized: ${lottery.finalized}`);

    return lottery;
  } catch (error: any) {
    if (error.message?.includes("Account does not exist")) {
      console.log("\nLottery account not found. Has it been initialized?");
    } else {
      throw error;
    }
  }
}

// CLI handling
const command = process.argv[2];

async function main() {
  switch (command) {
    case "build-tree": {
      const holderFile = process.argv[3];
      const outputFile = process.argv[4];
      if (!holderFile) {
        console.error("Usage: lottery-cli build-tree <holder-file> [output-file]");
        process.exit(1);
      }
      await buildTree(holderFile, outputFile);
      break;
    }

    case "find-winner": {
      const holderFile = process.argv[3];
      const vrfResult = process.argv[4];
      const outputFile = process.argv[5];
      if (!holderFile || !vrfResult) {
        console.error(
          "Usage: lottery-cli find-winner <holder-file> <vrf-result-hex> [output-file]"
        );
        process.exit(1);
      }
      await findWinner(holderFile, vrfResult, outputFile);
      break;
    }

    case "init": {
      const holderFile = process.argv[3];
      const walletPath = process.argv[4];
      const rpcUrl = process.argv[5];
      if (!holderFile) {
        console.error("Usage: lottery-cli init <holder-file> [wallet-path] [rpc-url]");
        process.exit(1);
      }
      await initializeLottery(holderFile, walletPath, rpcUrl);
      break;
    }

    case "set-vrf": {
      const randomnessAccount = process.argv[3];
      const walletPath = process.argv[4];
      const rpcUrl = process.argv[5];
      if (!randomnessAccount) {
        console.error(
          "Usage: lottery-cli set-vrf <randomness-account> [wallet-path] [rpc-url]"
        );
        process.exit(1);
      }
      await setVrfResult(randomnessAccount, walletPath, rpcUrl);
      break;
    }

    case "claim": {
      const holderFile = process.argv[3];
      const vrfResult = process.argv[4];
      const authority = process.argv[5];
      const winnerWalletPath = process.argv[6];
      const rpcUrl = process.argv[7];
      if (!holderFile || !vrfResult || !authority || !winnerWalletPath) {
        console.error(
          "Usage: lottery-cli claim <holder-file> <vrf-result-hex> <lottery-authority> <winner-wallet-path> [rpc-url]"
        );
        process.exit(1);
      }
      await claimWinnerWithAuthority(
        holderFile,
        vrfResult,
        authority,
        winnerWalletPath,
        rpcUrl
      );
      break;
    }

    case "state": {
      const authority = process.argv[3];
      const rpcUrl = process.argv[4];
      if (!authority) {
        console.error("Usage: lottery-cli state <lottery-authority> [rpc-url]");
        process.exit(1);
      }
      await getLotteryState(authority, rpcUrl);
      break;
    }

    default:
      console.log(`
Merkle Tree Weighted Lottery CLI

Usage: ts-node lottery-cli.ts <command> [options]

Commands:
  build-tree <holder-file> [output-file]
    Build Merkle tree from holder data and output root

  find-winner <holder-file> <vrf-result-hex> [output-file]
    Find the winner given a VRF result

  init <holder-file> [wallet-path] [rpc-url]
    Initialize lottery on-chain with Merkle root

  set-vrf <randomness-account> [wallet-path] [rpc-url]
    Set VRF result from Switchboard randomness account

  claim <holder-file> <vrf-result-hex> <lottery-authority> <winner-wallet-path> [rpc-url]
    Submit claim_winner transaction

  state <lottery-authority> [rpc-url]
    Fetch lottery state from on-chain

Examples:
  yarn lottery build-tree holders.json tree-output.json
  yarn lottery find-winner holders.json 0x1234...abcd winner-output.json
  yarn lottery init holders.json ~/.config/solana/id.json
  yarn lottery set-vrf <randomness-pubkey> ~/.config/solana/id.json
  yarn lottery claim holders.json 0x1234...abcd <authority> winner-wallet.json
`);
  }
}

main().catch((error) => {
  console.error("Error:", error);
  process.exit(1);
});
